{
    "contents" : "# print out header code (e.g. initializations, etc...)\n.preamble <- function(lang, map, print.rcs, mod){\n  if (lang == 'SAS') {\n    if (print.rcs) {\n      \n      cat(sprintf('/* %-32s %-20s\\n', 'Model Variable', 'Reason Code'))\n      cat(sprintf(' * %s\\n', paste(rep('-', 45), collapse='')))\n      \n      for (attr in names(map)) {\n        cat(sprintf(' * %-32s %-20s\\n', attr, map[[attr]]))\n      }\n      cat(' */\\n\\n')\n    }\n    cat(sprintf('%sfinal_score_0 =  %.10f;\\n', .s(1), mod$initF))\n  } else if (lang == 'ECL'){\n    cat(sprintf('%sfinal_score_0 :=  %.10f;\\n', .s(1), mod$initF))    \n  }\n}\n\n# print out footer code (e.g. sum scores and reason code values) \n.postamble <- function(lang, map, print.rcs, n.trees){\n  if (lang == 'SAS') {\n    if(print.rcs) {\n      cat('/* Reason Code Sums */\\n\\n')\n      for (attr in names(map)) {\n        cat(sprintf('%sAA_%s = sum(of %s:, 0);\\n', .s(1), map[[attr]],\n                    map[[attr]]))\n      }\n    }\n    cat('\\n/* Final Score Sum */\\n\\n')\n    cat(sprintf('%sfinal_score = sum(of final_score:);\\n', .s(1)))\n    \n  } else if (lang == 'ECL') {\n    cat('\\n// Final Score Sum \\n\\n')\n    cat(sprintf('%sfinal_score := sum(', .s(1)))\n    for (n in 0:n.trees) {\n      if ((n %% 5 == 0) | n == 0)\n        cat(sprintf('\\n%sfinal_score_%i, ', .s(2), n))\n      else if (n == n.trees)\n        cat(sprintf('final_score_%i); ', n))\n      else\n        cat(sprintf('final_score_%i, ', n))\n    }\n  }\n}\n\n# helper function to consistently indent\n.s <- function(d){\n  paste(rep(' ', d * 3), collapse='')\n}\n\n# specify the 'order' of the language\n# p = parent\n# c = child\n# d = depth\n# i = iteration (tree #)\n.preorder.sas <- function(mod, tree, p, c, d, i, ...){\n  # base condition is a terminal node\n  \n  # create data.frame of siblings to check later\n  sibs <- do.call(cbind, tree[3:5])\n  \n  # only print if not the root node\n  if (p > 0) {\n    \n    # if terminal node, return\n    if(tree[[1]][c] == -1) {\n      .visit.sas(mod, tree, p, c, d, i, ...)\n      \n      cat(sprintf(\"%send;\", .s(d)))\n      \n      # check for right sib. If not none, then print 'else'\n      if (any(which(sibs[p,] %in% (c-1)) != 3))\n        cat(sprintf(' else\\n', .s(d)))\n      else\n        cat('\\n')\n      \n      return()\n    }    \n    .visit.sas(mod, tree, p, c, d, i, ...)\n  }\n  \n  # visit each node: left, right, and missing\n  .preorder.sas(mod, tree, c, tree[[3]][c]+1, d+1, i, ...)\n  .preorder.sas(mod, tree, c, tree[[4]][c]+1, d+1, i, ...)\n  .preorder.sas(mod, tree, c, tree[[5]][c]+1, d+1, i, ...)\n  \n  # only print if not the root node\n  if (p > 0) {\n    cat(sprintf(\"%send;\", .s(d)))\n    if (any(which(sibs[p,] %in% (c-1)) != 3))\n      cat(sprintf(' else\\n', .s(d)))\n    else\n      cat('\\n')\n  }\n}\n\n.preorder.ecl <- function(mod, tree, p, c, d, i, ...){\n  # base condition is a terminal node\n  \n  # create data.frame of siblings to check later\n  sibs <- do.call(cbind, tree[3:5])\n  \n  if (p == 0) cat(sprintf('final_score_%i := map(\\n', i))\n  \n  # only print if not the root node\n  if (p > 0) {\n    \n    # if terminal node, return\n    if(tree[[1]][c] == -1) {\n      .visit.ecl(mod, tree, p, c, d, i, ...)      \n      return()\n    }\n    \n    .visit.ecl(mod, tree, p, c, d, i, ...)\n  }\n  \n  # every step gets a map and matching ')'\n  if (p > 0) cat(sprintf('\\n%smap(\\n', .s(d+1)))\n  \n  # visit each node: left, right, and missing\n  .preorder.ecl(mod, tree, c, tree[[3]][c]+1, d+1, i, ...)\n  .preorder.ecl(mod, tree, c, tree[[4]][c]+1, d+1, i, ...)\n  .preorder.ecl(mod, tree, c, tree[[5]][c]+1, d+1, i, ...)\n  \n  # only print if not the root node\n  if (p > 0) {\n    cat(', 0)')\n    if (any(which(sibs[p,] %in% (c-1)) != 3))\n      cat(',\\n')    \n  }\n  \n  if (p == 0) cat(', 0);')\n  \n  ### TODO add logic for printing reason codes ###\n  \n}\n\n# specify the syntax of the language\n.visit.sas <- function(mod, tree, p, c, d, i, ...){\n  \n  ###################\n  ###  ARGUMENTS  ###\n  ###################\n  dots <- list(...)\n  \n  # reason code map\n  if (is.null(dots[['map']])) map <- NULL else map <- dots[['map']]\n  \n  print.rcs <- FALSE\n  if (!is.null(dots[['print.rcs']])) print.rcs <- dots[['print.rcs']]\n  \n  # calculate the direction of split (dsp) here\n  dsp <- which(matrix(unlist(tree[3:5]), , 3)[p,] == (c-1))\n  dsp <- ifelse(dsp == 1, -1, ifelse(dsp == 2, 1, 0))\n  \n  # calculate the pieces needed for printing\n  cnd <- .condition(mod, tree, p, c, d, ...)\n  scr <- .scr.update(tree, p, c)\n  rcs <- .rc.update(tree, p, c, ...)\n  \n  ###################\n  ###  CONDITION  ###\n  ###################\n  \n  final <- list()\n  text <- ''\n  \n  if (cnd$type == 'missing'){\n    # Missing    \n    text <- sprintf('%sif missing(%s) then do;', .s(d), cnd$nm)\n    \n  } else if (cnd$type == 'factor'){\n    # Factor\n    text <- sprintf(\"%sif %s in ('%s') then do;\", .s(d), cnd$nm,\n                    paste(cnd$vl, collapse=\"','\"))\n    \n  } else if (cnd$type == 'ordered'){\n    # Ordered\n    text <- sprintf(\"%sif %s in ('%s') then do;\", .s(d), cnd$nm,\n                    paste(cnd$vl, collapse=\"','\"))\n    \n  } else if (cnd$type == 'numeric'){\n    # Numeric\n    if (dsp == -1) {\n      text <- sprintf(\"%sif .z < %s <= %s then do;\", .s(d), cnd$nm, cnd$vl)\n    } else {\n      text <- sprintf(\"%sif %s > %s then do;\", .s(d), cnd$nm, cnd$vl)\n    }    \n  }\n  final <- c(final, text, '\\n')\n  \n  ####################\n  ### SCORE UPDATE ###\n  ####################\n  \n  # only print if score update is not zero and not a terminal node\n  if (scr != 0 & tree[[1]][c] == -1) {\n    text <- sprintf('%sfinal_score_%i = %.10f;', .s(d+1), i, scr)\n    final <- c(final, text, '\\n')\n  }\n  \n  ###################\n  ### REASON CODE ###\n  ###################\n  \n  # only print if reason code update is not zero\n  if (print.rcs) {\n    if (rcs != 0) {\n      nm <- ifelse(is.null(map[[cnd$nm]]), cnd$nm, map[[cnd$nm]])\n      sfx <- sprintf('_%i_%i', i, p)\n      text <- sprintf('%s%s%s = %.10f;', .s(d+1), nm, sfx, rcs)\n      final <- c(final, text, '\\n')\n    }\n  }\n  lapply(final, cat)\n}\n\n.visit.ecl <- function(mod, tree, p, c, d, i, ...){\n  \n  ###################\n  ###  ARGUMENTS  ###\n  ###################\n  dots <- list(...)\n  \n  # reason code map\n  if (is.null(dots[['map']])) map <- NULL else map <- dots[['map']]\n  \n  print.rcs <- FALSE\n  if (!is.null(dots[['print.rcs']])) print.rcs <- dots[['print.rcs']]\n  \n  # calculate the direction of split (dsp) here\n  dsp <- which(matrix(unlist(tree[3:5]), , 3)[p,] == (c-1))\n  dsp <- ifelse(dsp == 1, -1, ifelse(dsp == 2, 1, 0))\n  \n  # calculate the pieces needed for printing\n  cnd <- .condition(mod, tree, p, c, d, ...)\n  scr <- .scr.update(tree, p, c)\n  rcs <- .rc.update(tree, p, c, ...)\n  \n  sibs <- do.call(cbind, tree[3:5])\n  \n  ###################\n  ###  CONDITION  ###\n  ###################\n  \n  final <- list()\n  text <- ''  \n  \n  ####################\n  ### SCORE UPDATE ###\n  ####################\n  \n  # only print if score update is not zero\n  \n  if (cnd$type == 'missing'){\n    # check if factor\n    # Missing    \n    text <- sprintf('%s(%s = %s) => ', .s(d), cnd$nm, cnd$null.val)\n    \n  } else if (cnd$type == 'factor'){\n    # Factor\n    text <- sprintf(\"%s(%s in ['%s']) => \", .s(d), cnd$nm,\n                    paste(cnd$vl, collapse=\"','\"))\n    \n  } else if (cnd$type == 'ordered'){\n    # Ordered\n    text <- sprintf(\"%s(%s in ['%s']) => \", .s(d), cnd$nm,\n                    paste(cnd$vl, collapse=\"','\"))\n    \n  } else if (cnd$type == 'numeric'){\n    # Numeric\n    if (dsp == -1) {\n      text <- sprintf(\"%s(NULL < %s and %s <= %s) => \", .s(d), cnd$nm,\n                      cnd$nm, cnd$vl)\n    } else {\n      text <- sprintf(\"%s(%s > %s) => \", .s(d), cnd$nm, cnd$vl)\n    }\n  }  \n  \n  # only print if score !=0 and a terminal node\n  if (scr != 0 & tree[[1]][c] == -1) {\n    final <- paste0(text, sprintf('%.10f', scr))\n    if (any(which(sibs[p,] %in% (c-1)) != 3)) # check if last leaf in branch\n      final <- c(final, ',\\n')\n  } else\n    final <- text\n  \n  lapply(final, cat)  \n}\n\n# function for generating conditional logic\n.condition <- function(mod, tree, p, c, d, ...) {\n  \n  vid <- tree[[1]][p]\n  vnm <- mod$var.names[vid+1]\n  vtp <- mod$var.type[vid+1]\n  vlv <- mod$var.levels[[vid+1]]\n  \n  # direction of split\n  dsp <- which(matrix(unlist(tree[3:5]), , 3)[p,] == (c-1))\n  dsp <- ifelse(dsp == 1, -1, ifelse(dsp == 2, 1, 0))\n  \n  # check if direction missing\n  if (dsp == 0) {\n    ret.txt <- list('type'='missing', 'nm'=vnm, 'vl'=NULL)\n    if (vtp > 0 | is.character(vlv))\n      ret.txt[['null.val']] <- \"''\"\n    else\n      ret.txt[['null.val']] <- 'NULL'\n  } else\n\n    # factor\n    if(vtp > 0) {\n      lvls <- vlv[mod$c.splits[[tree[[2]][p] + 1]] == dsp]\n      ret.txt <- list('type'='factor', 'nm'=vnm, 'vl'=lvls)\n    } else      \n    # ordered factor\n    if (is.character(vlv)) {\n      if(dsp == -1) {\n        lvls <- vlv[vlv <= tree[[2]][p] + 1]\n      } else {\n        lvls <- vlv[vlv >  tree[[2]][p] + 1]\n      }\n      ret.txt <- list('type'='ordered','nm'=vnm, 'vl'=lvls)\n    } else {\n    # numeric\n      ret.txt <- list('type'='numeric', 'nm'=vnm, 'vl'=tree[[2]][p])\n    }\n  \n  return(ret.txt)\n}\n\n# function for generating reason code points\n.rc.update <- function(tree, p, c, ...) {\n  dsp <- which(matrix(unlist(tree[3:5]), , 3)[p,] == (c-1))\n  dsp <- ifelse(dsp == 1, -1, ifelse(dsp == 2, 1, 0))\n  \n  # if split is missing, do not count towards reason codes\n  if (dsp == 0) return(0)\n  \n  # check ... for 'rc.calc'\n  dots <- list(...)  \n  rc.func <- dots[['rc.calc']]  \n  FUN <- NULL\n  \n  if (is.null(rc.func)) {\n    FUN <- function(tree, p, c) {\n      ppt <- tree[[8]][p]\n      lpt <- tree[[8]][tree[[3]][p] + 1] - ppt\n      rpt <- tree[[8]][tree[[4]][p] + 1] - ppt      \n      apt <- tree[[8]][c] - ppt\n      ret.val <- apt - min(lpt, rpt)\n    }\n  } else if (is.function(rc.func)) {\n    FUN <- rc.func\n  } else if (is.character(rc.func)) {\n    stop('RC functions passed as strings currently not supported')\n  }\n  \n  ret.val <- FUN(tree, p, c)\n  return(ret.val)\n  \n}\n\n# function for generating score contribution\n.scr.update <- function(tree, p, c, ...){\n  ret.val <- tree[[8]][c]\n  return(ret.val)\n}",
    "created" : 1428954842577.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1635702370",
    "id" : "C2BAF0C4",
    "lastKnownWriteTime" : 1410898555,
    "path" : "F:/STASH REPOS/mjollnir/R/translate.gbm-internal.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}