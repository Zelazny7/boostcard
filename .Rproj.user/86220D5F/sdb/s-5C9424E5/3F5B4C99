{
    "contents" : "getVarNames <- function(mod, n.trees) {\n  # return variable id for each tree\n  v <- sapply(mod$trees[n.trees], function(x) x[[1]][1])\n  return(mod$var.names[v + 1])\n}\n\n# make a data.frame of the variable type info\ngetGBMVarData <- function(mod, n.trees) {\n  # bundle the name, storage, measure, and position\n  vdata <- data.frame(\n    row.names = mod$var.names,\n    storage   = vapply(mod$var.levels, function(x) substr(typeof(x), 1, 1), 'x'),\n    measure   = ifelse(mod$var.type == 0, 'c', 'd'),\n    position  = 1:length(mod$var.names),\n    stringsAsFactors = FALSE)\n\n  # based on these we can define the type as used by GBM\n  vdata$type <- with(vdata, ifelse(storage == 'd' & measure == 'c', 'numeric',\n                            ifelse(measure == 'c', 'ordered',\n                                   'factor')))\n\n  # filter out variables not in the final model:\n  vdata[unique(getVarNames(mod, n.trees)), ]\n}\n\n### let's put this all into one mutha trucka! ###\n\n# return list of data.frames containing split info for each variable\ngetGBMClassing <- function(mod, n.trees, newdata = NULL, precision){\n  vdata <- getGBMVarData(mod, n.trees)\n\n  # extract the split information for each tree\n  sdata <- data.frame(t(sapply(mod$trees[n.trees], '[[', 2)))\n  colnames(sdata) <- c('value', 'left', 'right', 'missing')\n\n  # group the splits by variable\n  sdata <- split(sdata, getVarNames(mod, n.trees))\n  sdata <- lapply(sdata, function(x) x[order(x[,'value']), ])\n\n  ### loop over the sdata types and convert to boostbin object ###\n  classing <- list()\n  for (nm in names(sdata)) {\n    v <- vdata[nm,]\n    s <- sdata[[nm]]\n\n    if (v$type %in% c('factor', 'ordered')) {\n      classed <- process.factor(s, v, mod)\n    } else {\n      classed <- process.numeric(s, v, mod, newdata, precision)\n    }\n    classing[[nm]] <- classed\n  }\n\n  return(classing)\n}\n\nprocess.factor <- function(s, v, mod) {\n  value <- mod$var.levels[[v$position]]\n\n  if (v$type == 'factor') {\n    # map -1/1 to GBM tree left/right column indices\n    uniq <- unique(lapply(mod$c.splits, function(x) ifelse(x == -1, 2, 3)))\n\n    # index the unique splits by the GBM value\n    vals <- match(mod$c.splits[s$value + 1], unique(mod$c.splits))\n  } else {\n    uids <- seq_along(value)\n    uniq <- lapply(unique(s$value), function(x) ifelse(uids < x + 1, 2, 3))\n    vals <- match(s$value, unique(s$value))\n  }\n\n  # index the variable data.frame columns to pull in the score splits\n  res  <- sapply(1:nrow(s), function(n) as.numeric(s[n, uniq[vals][[n]]]))\n\n  # for each factor level, sum all scores to get the final summation\n  scores <- apply(res, 1, sum)\n\n  # output a list containing scores for each level of factor\n  out <- structure(list(\n    name  = row.names(v),\n    type  = 'factor',\n    missing = sum(s$missing),\n    value = value,\n    score = c(scores),\n    pts.lost = min(scores) - scores),\n    class = 'classed')\n\n  return(out)\n}\n\n# process.ordered <- function(s, v, mod) {\n#   # same result as process numeric with different levels\n#   out <- process.numeric(s, v, mod, precision = NULL)\n#\n#   lvls <- mod$var.levels[[v$position]]\n#   uids <- seq_along(lvls)\n#   uniq <- lapply(unique(s$value), function(x) ifelse(uids < x + 1, 2, 3))\n#\n#   vals <- match(s$value, unique(s$value))\n#\n#   res  <- sapply(1:nrow(s), function(n) as.numeric(s[n, uniq[vals][[n]]]))\n#\n#   scores <- apply(res, 1, sum)\n#\n#   out$type  <- 'ordered'\n#   return(out)\n# }\n\nprocess.numeric <- function(s, v, mod, newdata=NULL, precision) {\n\n  if (!is.null(newdata)) {\n    ux <- sort(unique(newdata[,row.names(v)]))\n    s$value <- ux[findInterval(s$value, ux, rightmost.closed = T) + 1]\n  }\n\n  # aggregate the scores by the new values\n  split <- aggregate(. ~ value, data.frame(s[1:4]), sum)\n\n  # calc decum and cum sums for left and right splits - gonna add them\n  split$left <- rev(cumsum(rev(split$left)))\n  split$right <- cumsum(split$right)\n\n  first <- split$left[1]\n  last  <- rev(split$right)[1]\n\n  # need to guard against binary splits\n  if(length(split$value) == 1) {\n    score <- c(first, last)\n  } else {\n    score <- c(split$left, 0) + c(0, split$right)\n  }\n\n  value <- c(split$value, Inf)\n\n  # round numeric weights to the nearest <precision>\n  if (!is.null(precision)) {\n    rnd <- round(score / precision, 1) * precision\n    score <- tapply(score, rnd, FUN = mean)\n    value <- tapply(value, rnd, max)\n  }\n\n  out <- structure(list(\n      name  = row.names(v),\n      type  = 'numeric',\n      missing = sum(split$missing),\n      value = value[order(value)],\n      score = score[order(value)],\n      pts.lost = min(score) - score),\n      class = 'classed')\n\n  return(out)\n}\n\n#' Create a scorecard object from a GBM model\n#'\n#' Given a GBM object with \\code{n.minobsinnode == 1}, \\code{gbm.to.scorecard}\n#' aggregates the model stumps and generates a traditional main-effects\n#' scorecard.\n#'\n#' The scorecard object supports generic predict and print methods.\n#'\n#' @param mod A GBM model object\n#' @param n.trees A single number representing 1:n trees or a vector of trees\n#' for which to extract scorecard logic\n#' @param rnd an optional parameter used to round numeric split values. Can be\n#' used to reduce the size of continuous scorecard predictors.\n#'\n#' @return A scorecard object\n#' @export gbm.to.scorecard\ngbm.to.scorecard <- function(mod, n.trees, newdata = NULL, precision = 0.25) {\n  # check interaction depth of GBM mod\n  if (mod$interaction.depth > 1) {\n    stop(sprintf(\"GBM interaction depth cannot exceed 1: %i\",\n                 mod$interaction.depth))\n  }\n\n  # allow for single number or vector of trees\n  if (length(n.trees) == 1) n.trees <- 1:n.trees\n\n  classing <- c(initF=mod$initF, getGBMClassing(mod, n.trees, newdata, precision))\n\n  structure(classing, class=\"scorecard\")\n}\n\nscore.scorecard <- function(s, data) {\n  var <- data[, s$name]\n\n  out <- numeric(nrow(data))\n  out[is.na(var)] <- s$missing\n\n  if (s$type == 'factor') {\n    for(i in seq_along(s$value)){\n      out[var == s$value[i]] <- s$score[i]\n    }\n    return(out)\n  } else\n    if (s$type == 'ordered') {\n      var <- as.integer(ordered(var, levels = s$levels)) - 1\n      for(i in seq_along(s$value)) {\n        if(i == 1) {\n          out[var < s$value[i]] <- s$score[i]\n        }\n        out[var >= s$value[i]] <- s$score[i + 1]\n      }\n      return(out)\n    }\n  if (s$type == 'numeric') {\n    for(i in seq_along(s$value)) {\n      if(i == 1) {\n        out[var < s$value[i]] <- s$score[i]\n      }\n      out[var >= s$value[i]] <- s$score[i + 1]\n    }\n    return(out)\n  }\n}\n\n#' generic predict method for scorecard objects\n#'\n#' Generates a prediction based on a scorecard object. Equivalent to the using\n#' \\code{predict.gbm} on a stump model\n#'\n#' \\code{predict.scorecard} uses the column names of \\code{newdata} to generate\n#' the scorecard predictions for each variable.\n#'\n#' @param object A scorecard object\n#' @param newdata A data.frame containing the columns used to generate the\n#' scorecard\n#' @param ...  Arguments passed to \\code{predict.default}\n#'\n#' @return a numeric vector of length \\code{nrow(newdata))}\n#' @export predict.scorecard\npredict.scorecard <- function(object, newdata, ...) {\n  # check that newdata has names attribute\n  if (is.null(attr(newdata, \"names\"))) {\n    stop(\"Supplied data.frame does not have column names\")\n  }\n\n  # check that the names in the scorecard are found in newdata\n  not.found <- !(names(object[-1]) %in% names(newdata))\n  if (any(not.found)) {\n    vars <- paste(names(object[-1])[not.found], collapse=', ')\n    err <- sprintf(\"Vars not found in dataset: %s\", vars)\n    stop(err)\n  }\n\n  scored <- vapply(object[-1], score.scorecard, numeric(nrow(newdata)), newdata)\n  scored <- apply(scored, 1, sum) + object$initF\n  return(scored)\n}\n\n#' generic print method for scorecard object\n#'\n#' Prints each model variable in SAS format. Currently does not support\n#' printing ordered factors\n#'\n#' The generated SAS code is printed to standard output. Use \\code{sink} to\n#' redirect the output to a file.\n#'\n#' @param x A scorecard object\n#' @param ...  Arguments passed to \\code{print.default}\n#' @export print.scorecard\n# print.scorecard <- function(x, ...) {\n#   # check if ordered factor is provided. Not supported yet\n#   vtypes <- vapply(x[-1], function(x) x[['type']], character(1))\n#   if (any(vtypes == \"ordered\")) {\n#     warning(\"Printing ordered factors not yet supported\")\n#   }\n#\n#   # print the intercept\n#   cat(sprintf(\"final_score_0 = %.10f;\\n\", x$initF))\n#\n#   # loop over values and print each\n#   for (k in seq_along(x[-1])) {\n#     var <- x[-1][[k]]\n#\n#     cat(sprintf(\"\\n\\n/* variable: %s */\\n\", var$var))\n#     cat(sprintf(\"if missing(%s)\\n\\tthen final_score%i = %-.10f;\",\n#                 var$var, k, var$missing))\n#\n#     if (var$type == 'numeric') {\n#       for (i in seq_along(var$value)) {\n#\n#         lhs <- sprintf(\"else if %s < %s\", var$var, var$value[i])\n#         rhs <- sprintf(\"\\n\\t then final_score%i = \", k)\n#         scr <- sprintf(\"%-.10f;\", var$score[i])\n#         cat(\"\\n\", lhs, rhs, scr, sep = \"\")\n#       }\n#       rhs <- sprintf(\"\\nelse final_score%i = \", k)\n#       scr <- sprintf(\"%-.10f;\", var$score[i+1])\n#       cat(rhs, scr, sep = \"\")\n#\n#     } else\n#       if (var$type == 'factor') {\n#         for (i in seq_along(var$value)) {\n#\n#           lhs <- sprintf(\"if %s = %s\", var$var, var$value[i])\n#           rhs <- sprintf(\"\\n\\t then final_score%i = \", k)\n#           scr <- sprintf(\"%-.10f;\", var$score[i])\n#           cat(\"\\n\", lhs, rhs, scr, sep=\"\")\n#         }\n#       } else\n#         if (var$type == 'ordered') {\n#           lhs <- sprintf(\"if %s = %s\", var$var, var$value[i])\n#           rhs <- sprintf(\"\\n\\t then final_score%i = \", k)\n#           scr <- sprintf(\"%-.10f;\", var$score[i])\n#           cat(\"\\n\", lhs, rhs, scr, sep=\"\")\n#         }\n#   }\n# }\n",
    "created" : 1427216527021.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "334461653",
    "id" : "3F5B4C99",
    "lastKnownWriteTime" : 1428959310,
    "path" : "F:/R Dev/boostcard/R/boostcard.R",
    "project_path" : "R/boostcard.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}